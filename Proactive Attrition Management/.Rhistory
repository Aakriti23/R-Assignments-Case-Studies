setwd("F:\\Business Analytics\\Case studies\\Proactive-Attrition-Management-Logistic Regression")
mydata<-read.csv("Proactive Attrition Management-Logistic Regression Case Study.csv")
mydata$CUSTOMER<-NULL
mydata$RETCALLS<-NULL
mydata$RETACCPT<-NULL
mydata$INCMISS<-NULL
mydata$RETCALL<-NULL
mydata$SETPRCM<-NULL
mydata$CHURNDEP<-NULL
mydata$CSA<-NULL
mydata <- mydata[complete.cases(mydata), ]
mydata$REVENUE[mydata$REVENUE>224.3076]<-224.3076
mydata$MOU[mydata$MOU>2441.42]<-2441.42
mydata$RECCHRGE[mydata$RECCHRGE>119.99]<-119.99
mydata$DIRECTAS[mydata$DIRECTAS>9.65]<-9.65
mydata$OVERAGE[mydata$OVERAGE>424.98]<-424.98
mydata$ROAM[mydata$ROAM>21.3892]<-21.3892
mydata$CHANGEM[mydata$CHANGEM>735.959999999999]<-735.959999999999
mydata$CHANGER[mydata$CHANGER>117.739599999999]<-117.739599999999
mydata$DROPVCE[mydata$DROPVCE>42]<-42
mydata$BLCKVCE[mydata$BLCKVCE>46.67]<-46.67
mydata$UNANSVCE[mydata$UNANSVCE>178.67]<-178.67
mydata$CUSTCARE[mydata$CUSTCARE>21]<-21
mydata$THREEWAY[mydata$THREEWAY>4]<-4
mydata$MOUREC[mydata$MOUREC>771.060799999999]<-771.060799999999
mydata$OUTCALLS[mydata$OUTCALLS>164]<-164
mydata$INCALLS[mydata$INCALLS>77]<-77
mydata$PEAKVCE[mydata$PEAKVCE>499.67]<-499.67
mydata$OPEAKVCE[mydata$OPEAKVCE>436.973599999999]<-436.973599999999
mydata$DROPBLK[mydata$DROPBLK>71]<-71
mydata$CALLFWDV[mydata$CALLFWDV>0]<-0
mydata$CALLWAIT[mydata$CALLWAIT>23.33]<-23.33
mydata$MONTHS[mydata$MONTHS>49]<-49
mydata$UNIQSUBS[mydata$UNIQSUBS>5]<-5
mydata$ACTVSUBS[mydata$ACTVSUBS>4]<-4
mydata$PHONES[mydata$PHONES>7]<-7
mydata$MODELS[mydata$MODELS>5]<-5
mydata$EQPDAYS[mydata$EQPDAYS>1143]<-1143
mydata$AGE1[mydata$AGE1>74]<-74
mydata$AGE2[mydata$AGE2>76]<-76
mydata$REFER[mydata$REFER>1]<-1
mydata$CREDITAD[mydata$CREDITAD>1]<-1
mydata$SETPRC[mydata$SETPRC>199.99]<-199.99
mydata$CHURN<-as.factor(mydata$CHURN)
mydata$CHILDREN<-as.factor(mydata$CHILDREN)
mydata$CREDITA<-as.factor(mydata$CREDITA)
mydata$CREDITAA<-as.factor(mydata$CREDITAA)
mydata$CREDITB<-as.factor(mydata$CREDITB)
mydata$CREDITC<-as.factor(mydata$CREDITC)
mydata$CREDITDE<-as.factor(mydata$CREDITDE)
mydata$CREDITGY<-as.factor(mydata$CREDITGY)
mydata$CREDITZ<-as.factor(mydata$CREDITZ)
mydata$PRIZMRUR<-as.factor(mydata$PRIZMRUR)
mydata$PRIZMUB<-as.factor(mydata$PRIZMUB)
mydata$PRIZMTWN<-as.factor(mydata$PRIZMTWN)
mydata$REFURB<-as.factor(mydata$REFURB)
mydata$WEBCAP<-as.factor(mydata$WEBCAP)
mydata$TRUCK<-as.factor(mydata$TRUCK)
mydata$RV<-as.factor(mydata$RV)
mydata$OCCPROF<-as.factor(mydata$OCCPROF)
mydata$OCCCLER<-as.factor(mydata$OCCCLER)
mydata$OCCCRFT<-as.factor(mydata$OCCCRFT)
mydata$OCCSTUD<-as.factor(mydata$OCCSTUD)
mydata$OCCHMKR<-as.factor(mydata$OCCHMKR)
mydata$OCCRET<-as.factor(mydata$OCCRET)
mydata$OCCSELF<-as.factor(mydata$OCCSELF)
mydata$OWNRENT<-as.factor(mydata$OWNRENT)
mydata$MARRYUN<-as.factor(mydata$MARRYUN)
mydata$MARRYYES<-as.factor(mydata$MARRYYES)
mydata$MARRYNO<-as.factor(mydata$MARRYNO)
mydata$MAILORD<-as.factor(mydata$MAILORD)
mydata$MAILRES<-as.factor(mydata$MAILRES)
mydata$MAILFLAG<-as.factor(mydata$MAILFLAG)
mydata$TRAVEL<-as.factor(mydata$TRAVEL)
mydata$PCOWN<-as.factor(mydata$PCOWN)
mydata$CREDITCD<-as.factor(mydata$CREDITCD)
mydata$NEWCELLY<-as.factor(mydata$NEWCELLY)
mydata$NEWCELLN<-as.factor(mydata$NEWCELLN)
mydata$MCYCLE<-as.factor(mydata$MCYCLE)
var_num<-sapply(mydata,is.factor)
cat_data<-mydata[,var_num]
cont_data<-mydata[,!var_num]
library(MASS)
tbl=table(cat_data$CHURN,cat_data$CHILDREN)
chisq.test(tbl)
names(cat_data)
tbl=table(cat_data$CHURN,cat_data$TRUCK)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITA)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITAA)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDIT)
tbl=table(cat_data$CHURN,cat_data$CREDITB)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITC)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITDE)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITGY)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITZ)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$PRIZMRUR)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$PRIZMUB)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$PRIZMTWN)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$REFURB)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$WEBCAP)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$TRUCK)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$RV)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCPROF)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCCLER)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCCRFT)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCSTUD)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCHMKR)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCRET)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OCCSELF)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$OWNRENT)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MARRYUN)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MARRYYES)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MARRYNO)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MAILORD)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MAILRES)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MAILFLAG)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$TRAVEL)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$PCOWN)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$CREDITCD)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$NEWCELLY
)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$NEWCELLN)
chisq.test(tbl)
tbl=table(cat_data$CHURN,cat_data$MCYCLE)
chisq.test(tbl)
mydata$TRUCK<-NULL
mydata$CREDITGY<-NULL
mydata$CREDITZ<-NULL
mydata$RV<-NULL
mydata$OCCCLER<-NULL
mydata$OCCSTUD<-NULL
mydata$MAILFLAG<-NULL
mydata$PCOWN<-NULL
mydata$MCYCLE<-NULL
require(car)
library(caret)
library(e1071)
boxcoxtrans <- preProcess(mydata, method = "YeoJohnson")
mydata<- predict(boxcoxtrans, mydata)
training<-mydata[mydata$CALIBRAT==1,]
testing<-mydata[mydata$CALIBRAT==0,]
training$CALIBRAT<-NULL
testing$CALIBRAT<-NULL
training$CALLFWDV<-NULL
testing$CALLFWDV<-NULL
fit<-glm(CHURN~ .,data = training,
family = binomial(logit))
# Assuming the input is a stored binomial GLM object
Concordance = function(GLM.binomial) {
outcome_and_fitted_col = cbind(GLM.binomial$y, GLM.binomial$fitted.values)
# get a subset of outcomes where the event actually happened
ones = outcome_and_fitted_col[outcome_and_fitted_col[,1] == 1,]
# get a subset of outcomes where the event didn't actually happen
zeros = outcome_and_fitted_col[outcome_and_fitted_col[,1] == 0,]
# Equate the length of the event and non-event tables
if (length(ones[,1])>length(zeros[,1])) {ones = ones[1:length(zeros[,1]),]}
else {zeros = zeros[1:length(ones[,1]),]}
# Following will be c(ones_outcome, ones_fitted, zeros_outcome, zeros_fitted)
ones_and_zeros = data.frame(ones, zeros)
# initiate columns to store concordant, discordant, and tie pair evaluations
conc = rep(NA, length(ones_and_zeros[,1]))
disc = rep(NA, length(ones_and_zeros[,1]))
ties = rep(NA, length(ones_and_zeros[,1]))
for (i in 1:length(ones_and_zeros[,1])) {
# This tests for concordance
if (ones_and_zeros[i,2] > ones_and_zeros[i,4])
{conc[i] = 1
disc[i] = 0
ties[i] = 0}
# This tests for a tie
else if (ones_and_zeros[i,2] == ones_and_zeros[i,4])
{
conc[i] = 0
disc[i] = 0
ties[i] = 1
}
# This should catch discordant pairs.
else if (ones_and_zeros[i,2] < ones_and_zeros[i,4])
{
conc[i] = 0
disc[i] = 1
ties[i] = 0
}
}
# Here we save the various rates
conc_rate = mean(conc, na.rm=TRUE)
disc_rate = mean(disc, na.rm=TRUE)
tie_rate = mean(ties, na.rm=TRUE)
Somers_D<-conc_rate - disc_rate
gamma<- (conc_rate - disc_rate)/(conc_rate + disc_rate)
#k_tau_a<-2*(sum(conc)-sum(disc))/(N*(N-1)
return(list(concordance=conc_rate, num_concordant=sum(conc), discordance=disc_rate, num_discordant=sum(disc), tie_rate=tie_rate,num_tied=sum(ties),
somers_D=Somers_D, Gamma=gamma))
}
#Concordance(m4)
Concordance(fit)  #NOTE: To run these command, first run concordance function in Concordance.R
#Stepwise regression
step1=step(fit)
fit2<-glm(CHURN ~ REVENUE + MOU + RECCHRGE + OVERAGE + ROAM + CHANGEM +
CHANGER + DROPVCE + BLCKVCE + UNANSVCE + CUSTCARE + THREEWAY +
MOUREC + OUTCALLS + INCALLS + PEAKVCE + CALLWAIT +
MONTHS + UNIQSUBS +  MODELS + EQPDAYS + AGE1 +
CHILDREN + CREDITAA + CREDITB + CREDITC + CREDITDE + PRIZMUB +
REFURB + WEBCAP + OCCHMKR + MARRYUN + MAILRES + CREDITCD +
NEWCELLY + INCOME + CREDITAD + SETPRC,data = training,
family = binomial(logit))
Concordance(fit2)
summary(fit2)
fit2<-glm(CHURN ~ REVENUE + MOU + RECCHRGE + OVERAGE + ROAM + CHANGEM +
CHANGER + DROPVCE + BLCKVCE + UNANSVCE + CUSTCARE + THREEWAY +
MOUREC + OUTCALLS + INCALLS + PEAKVCE + CALLWAIT +
MONTHS + UNIQSUBS +  EQPDAYS + AGE1 +
CHILDREN + CREDITAA + CREDITB + CREDITC + CREDITDE + PRIZMUB +
REFURB + WEBCAP + OCCHMKR + MARRYUN + MAILRES + CREDITCD +
NEWCELLY + INCOME + CREDITAD + SETPRC,data = training,
family = binomial(logit))
Concordance(fit2)
################################ VALIDATION ##############################
#Decile Scoring for
##Training dataset
train1<- cbind(training, Prob=predict(fit2, type="response"))
##Creating Deciles
decLocations <- quantile(train1$Prob, probs = seq(0.1,0.9,by=0.1))
train1$decile <- findInterval(train1$Prob,c(-Inf,decLocations, Inf))
train1$decile<-factor(train1$decile)
decile_grp<-group_by(train1,decile)
decile_summ_train<-summarize(decile_grp, total_cnt=n(), min_prob=min(p=Prob), max_prob=max(Prob), CHURN_cnt=sum(CHURN),
non_default_cnt=total_cnt -CHURN_cnt )
require(dplyr)
train1$decile<-factor(train1$decile)
decile_grp<-group_by(train1,decile)
decile_summ_train<-summarize(decile_grp, total_cnt=n(), min_prob=min(p=Prob), max_prob=max(Prob), CHURN_cnt=sum(CHURN),
non_default_cnt=total_cnt -CHURN_cnt )
View(decile_summ_train)
decile_summ_train<-summarize(decile_grp, total_cnt=n(), min_prob=min(p=Prob), max_prob=max(Prob), CHURN_cnt=sum(CHURN),
non_default_cnt=total_cnt -CHURN_cnt )
##Testing dataset
test1<- cbind(testing, Prob=predict(fit2,testing, type="response"))
##Creating Deciles
decLocations <- quantile(test1$Prob, probs = seq(0.1,0.9,by=0.1))
test1$decile <- findInterval(test1$Prob,c(-Inf,decLocations, Inf))
names(test1)
#Decile Analysis Reports
require(sqldf)
fit_test_DA2 <- sqldf("select decile, count(decile) as count, min(Prob) as Min_prob
, max(Prob) as max_prob
, sum(CHURN) as default_cnt
from test1
group by decile
order by decile desc")
write.csv(fit_test_DA2,"fit_test_DA2.csv",row.names = F)
################################ VALIDATION ##############################
#Decile Scoring for
##Training dataset
train1<- cbind(training, Prob=predict(fit2, type="response"))
##Creating Deciles
decLocations <- quantile(train1$Prob, probs = seq(0.1,0.9,by=0.1))
train1$decile <- findInterval(train1$Prob,c(-Inf,decLocations, Inf))
require(dplyr)
train1$decile<-factor(train1$decile)
decile_grp<-group_by(train1,decile)
decile_summ_train<-summarize(decile_grp, total_cnt=n(), min_prob=min(p=Prob), max_prob=max(Prob), CHURN_cnt=sum(CHURN),
non_default_cnt=total_cnt -CHURN_cnt )
fit_test_DA2 <- sqldf("select decile, count(decile) as count, min(Prob) as Min_prob
, max(Prob) as max_prob
, sum(CHURN) as default_cnt
from train1
group by decile
order by decile desc")
write.csv(fit_test_DA2,"fit_test_DA2.csv",row.names = F)
write.csv(fit_test_DA2,"fit_test_DA2.csv",row.names = F)
summary(fit2)
Concordance(fit2)
